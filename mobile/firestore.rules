rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    // Helper: auth email lowercased (for invite matching)
    function myEmail() {
      return request.auth.token.email != null
        ? request.auth.token.email.lower()
        : "";
    }

    // =========================================================
    // ADMIN HELPERS (must be defined before use in root matches)
    // =========================================================
    function isSuperAdminOfSociety(societyId) {
      return signedIn()
        && societyId is string
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin";
    }

    function isAdminOfSociety(societyId) {
      return signedIn()
        && societyId is string
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && (
          get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "admin"
          || get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin"
        );
    }

    // ============================================
    // ROOT POINTER: members/{uid}
    // Used to resolve societyId WITHOUT collectionGroup queries
    // ============================================
    match /members/{uid} {

      // any signed-in user can read (needed for phone-availability check during admin approve)
      allow read: if signedIn();

      // ✅ CREATE:
      // - self can create their pointer
      // - admin/super_admin can create pointer for another user during approval
      allow create: if signedIn()
        && request.resource.data.uid == uid
        && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"]
        && (request.resource.data.active == true || request.resource.data.active == false)
        && request.resource.data.societyId is string
        && (
          // self create
          request.auth.uid == uid
          // admin create (approval)
          || isAdminOfSociety(request.resource.data.societyId)
          || isSuperAdminOfSociety(request.resource.data.societyId)
        );

      // ✅ UPDATE:
      // - self updating their own pointer (including deactivation)
      // - OR admin/super_admin updating pointer of someone in the same society (for approval)
      allow update: if signedIn() && (
        // self update
        request.auth.uid == uid
        // admin update (approval) - prefer existing societyId if present
        || (
          (
            (resource.data.societyId is string && (isAdminOfSociety(resource.data.societyId) || isSuperAdminOfSociety(resource.data.societyId)))
            || (request.resource.data.societyId is string && (isAdminOfSociety(request.resource.data.societyId) || isSuperAdminOfSociety(request.resource.data.societyId)))
          )
        )
      );

      allow delete: if false;
    }

    // Helpers for society membership under societies/{societyId}/members/{uid}
    function memberPath(societyId) {
      return /databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid);
    }

    function isMember(societyId) {
      return signedIn() && exists(memberPath(societyId));
    }

    function member(societyId) {
      return get(memberPath(societyId));
    }

    function activeMember(societyId) {
      return isMember(societyId) && member(societyId).data.active == true;
    }

    // ✅ treat super_admin as admin-equivalent
    function isAdmin(societyId) {
      return activeMember(societyId)
        && (member(societyId).data.systemRole == "admin"
            || member(societyId).data.systemRole == "super_admin");
    }

    // ✅ Check if user is super admin
    function isSuperAdmin(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "super_admin";
    }

    // ✅ Check if user is guard (for violations: own reports only)
    function isGuard(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "guard";
    }

    // ✅ Check if user is resident (for violations: own flat only)
    function isResident(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "resident";
    }

    // ✅ STEP B: ADD THIS HELPER HERE
    function canReadMemberDoc(societyId, uid) {
      return signedIn()
        && (
          // user can read own member doc even if inactive
          (request.auth.uid == uid
            && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(uid)))
          // admin can read all
          || isAdmin(societyId)
        );
    }

    // ------------------------
    // Societies (multi-tenant root)
    // ------------------------
    match /societies/{societyId} {

      // BOOTSTRAP: allow first-time society creation by the signed-in creator
      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      // After creation, only active members can read the society doc
      allow read: if activeMember(societyId);

      // Only admin can update/delete society doc
      allow update, delete: if isAdmin(societyId);

      // ------------------------
      // Members under society
      // Invite → Self Signup → Claim Invite model
      // ------------------------
      match /members/{uid} {

        // ✅ CREATE:
        // - self-create (existing behavior)
        // - admin/super_admin create for other user during approval (NEW)
        allow create: if signedIn()
          && request.resource.data.uid == uid
          && request.resource.data.societyId == societyId
          && (request.resource.data.active == true || request.resource.data.active == false)
          && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"]
          && (
            // self create
            uid == request.auth.uid
            // admin create (approval)
            || isAdmin(societyId)
          );

        // Read: member can read self (even if inactive); admin can read all; guard can read all (for Residents Directory)
        allow read: if signedIn()
          && (
            uid == request.auth.uid
            || isAdmin(societyId)
            || (activeMember(societyId) && member(societyId).data.systemRole == "guard")
          );

        // Update:
        // - Self can update own member doc even if inactive (profile-only)
        // - Self can deactivate (set active=false)
        // - Admin can update any member (approval, role, etc.)
        allow update: if signedIn() && (
          // Guards: allow self-profile updates (phone/email/photo/shift) without strict role checks
          (
            uid == request.auth.uid
            && member(societyId).data.systemRole == "guard"
          )
          // Self deactivation: allow setting active from true to false
          || (
            uid == request.auth.uid
            && resource.data.active == true
            && request.resource.data.active == false
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
          )
          // Other roles: Self update (even if inactive) — but cannot change role or active
          || (
            uid == request.auth.uid
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
            && request.resource.data.active == resource.data.active
          )
          // Admin / Super Admin update
          || isAdmin(societyId)
        );

        // Delete: admin/super_admin can delete members (for rejection)
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Invites (email-based onboarding)
      // societies/{societyId}/invites/{inviteKey}
      // ------------------------
      match /invites/{inviteKey} {
        // ✅ Allow reads:
        // - Direct access (get): Admin of this society OR email match
        // - CollectionGroup queries (list): Email match only (societyId not available in collectionGroup context)
        allow get: if isAdmin(societyId)
          || (signedIn()
              && request.auth.token.email != null
              && resource.data.email is string
              && resource.data.email.lower() == myEmail());

        // ✅ CollectionGroup queries: Only email-based access (no societyId context)
        allow list: if signedIn()
          && request.auth.token.email != null
          && resource.data.email is string
          && resource.data.email.lower() == myEmail();

        // Admin creates invites ONLY
        allow create: if isAdmin(societyId)
          && request.resource.data.status == "pending"
          && request.resource.data.active == true
          && request.resource.data.email is string
          && request.resource.data.systemRole in ["guard", "resident", "admin", "super_admin"];

        // ✅ Claim invite: ONLY invited user can mark pending -> claimed
        allow update: if signedIn()
          && request.auth.token.email != null
          && resource.data.status == "pending"
          && resource.data.active == true
          && resource.data.email is string
          && resource.data.email.lower() == myEmail()
          && request.resource.data.status == "claimed"
          && request.resource.data.claimedByUid == request.auth.uid;

        // Optional: admin cleanup
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Notices (admin writes, members read)
      // ------------------------
      match /notices/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Complaints
      // ------------------------
      match /complaints/{id} {
        allow read: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || member(societyId).data.systemRole == "guard"
            || (!("visibility" in resource.data) || resource.data.visibility != "personal")
            || resource.data.residentUid == request.auth.uid
          );
        allow create: if activeMember(societyId)
          && (!("visibility" in request.resource.data) || request.resource.data.visibility in ["general", "personal"]);
        allow update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // SOS Requests
      // ------------------------
      match /sos_requests/{id} {
        allow create: if activeMember(societyId);

        allow read: if activeMember(societyId)
          && (
            member(societyId).data.systemRole in ["admin", "super_admin", "guard"]
            || resource.data.residentId == request.auth.uid
          );

        allow update: if activeMember(societyId)
          && member(societyId).data.systemRole in ["admin", "super_admin", "guard"];
        allow delete: if false;
      }

      // ------------------------
      // Violations
      // ------------------------
      match /violations/{id} {
        allow create: if isGuard(societyId)
          && request.resource.data.guardUid == request.auth.uid
          && request.resource.data.keys().hasAll(["guardUid", "flatNo", "violationType", "createdAt", "updatedAt"])
          && request.resource.data.violationType in ["PARKING", "FIRE_LANE", "OTHER"];
        allow read: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || (isGuard(societyId) && resource.data.guardUid == request.auth.uid)
            || (isResident(societyId) && resource.data.flatNo != null && member(societyId).data.flatNo != null && resource.data.flatNo.upper() == member(societyId).data.flatNo.upper())
          );
        allow update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Visitors
      // ------------------------
      match /visitors/{id} {
        allow read: if activeMember(societyId);
        allow create: if activeMember(societyId)
          && member(societyId).data.systemRole == "guard"
          && request.resource.data.guard_uid == request.auth.uid
          && request.resource.data.status == "PENDING";
        allow update: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || (
              member(societyId).data.systemRole == "resident"
              && resource.data.flat_no.upper() == member(societyId).data.flatNo.upper()
              && request.resource.data.status in ["APPROVED", "REJECTED"]
              && request.resource.data.approved_by == request.auth.uid
            )
          );
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Resident Signups (legacy)
      // ------------------------
      match /residentSignups/{id} {
        allow create: if request.resource.data.status == "PENDING"
          && request.resource.data.society_id == societyId
          && request.resource.data.keys().hasAll(["name", "email", "phone", "flat_no", "password", "signup_id", "society_id"]);

        allow read: if isAdmin(societyId);

        allow update: if isAdmin(societyId)
          && (
            request.resource.data.status in ["APPROVED", "REJECTED"]
            && (request.resource.data.keys().hasAny(["approved_by", "rejected_by"]))
          );

        allow delete: if false;
      }

      // ------------------------
      // Flats
      // ------------------------
      match /flats/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // Default deny for unknown collections under a society
      match /{col}/{doc} {
        allow read, write: if false;
      }
    }

    // ------------------------
    // PUBLIC SOCIETY DIRECTORY (root collection: public_societies)
    // ------------------------
    match /public_societies/{pubSocietyId} {
      // Any signed-in user can read active public society metadata
      allow read: if signedIn() && resource.data.active == true;

      // Admins of this society may update nameLower only (for search after name change).
      allow update: if signedIn()
        && isAdmin(pubSocietyId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['nameLower'])
        && request.resource.data.nameLower is string;

      // Create/delete managed by backend / admin tools only
      allow create, delete: if false;

      // Units under a public society
      match /units/{unitId} {
        allow read: if signedIn() && resource.data.active == true;
        allow write: if false;
      }

      // Resident join requests under a public society
      match /join_requests/{uid} {
        function isSelf() {
          return signedIn() && request.auth.uid == uid;
        }
        function isSocietyAdmin() {
          return isAdmin(pubSocietyId);
        }

        allow create: if isSelf()
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.status == "PENDING";

        allow get: if isSelf() || isSocietyAdmin();
        allow list: if isSocietyAdmin();

        allow update: if (
            isSelf()
            && resource.data.status == "PENDING"
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(
              ["name", "unitLabel", "residencyType"]
            )
          )
          || isSocietyAdmin();

        allow delete: if isSocietyAdmin();
      }
    }

    // society code mapping for "join by code"
    match /societyCodes/{code} {
      allow read: if true;

      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      allow update, delete: if false;
    }

    // ------------------------
    // unique_phones/{phoneHash}
    // ------------------------
    match /unique_phones/{phoneHash} {
      allow read, write: if signedIn();
    }

    // ------------------------
    // Guard join codes (6-digit, 24h validity).
    // ------------------------
    match /guard_join_codes/{code} {
      allow read: if true;
      allow create: if signedIn() && isAdmin(request.resource.data.societyId);
      allow update, delete: if signedIn() && isAdmin(resource.data.societyId);
    }

    // Default deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
