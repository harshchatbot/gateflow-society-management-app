rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    // Helper: auth email lowercased (for invite matching)
    function myEmail() {
      return request.auth.token.email != null
        ? request.auth.token.email.lower()
        : "";
    }

    // =========================================================
    // ADMIN HELPERS (must be defined before use in root matches)
    // =========================================================
    function isSuperAdminOfSociety(societyId) {
      return signedIn()
        && societyId is string
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin";
    }

    function isAdminOfSociety(societyId) {
      return signedIn()
        && societyId is string
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && (
          get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "admin"
          || get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin"
        );
    }

    // ✅ Global Super Admin (root pointer check)
    // Used for privileged root collections like public_societies
    function isGlobalSuperAdmin() {
      return signedIn()
        && exists(/databases/$(database)/documents/platform_admins/$(request.auth.uid))
        && (
          get(/databases/$(database)/documents/platform_admins/$(request.auth.uid)).data.role == "super_admin"
          || get(/databases/$(database)/documents/platform_admins/$(request.auth.uid)).data.systemRole == "super_admin"
        )
        && get(/databases/$(database)/documents/platform_admins/$(request.auth.uid)).data.active == true;
    }

    
    // ============================================
    // ROOT POINTER: members/{uid}
    // ============================================
    match /members/{uid} {

      // ✅ Read only: self OR global super admin OR society admin of that society
      allow get: if signedIn()
        && (
          request.auth.uid == uid
          || isGlobalSuperAdmin()
          || (resource.data.societyId is string && isAdminOfSociety(resource.data.societyId))
        );

      // ✅ Never list root members (prevents leaking user directory/roles)
      allow list: if false;

      // ✅ Create allowed in two modes:
      // Mode 1: Minimal doc (pending society request pointer) — used by createSocietyCreationRequest()
      // Mode 2: Full pointer doc (legacy/normal pointer creation)
      allow create: if signedIn()
        && request.resource.data.uid == uid
        && (
          // MODE 1: Self pending society request pointer-only create
          (
            request.auth.uid == uid
            &&
            request.resource.data.keys().hasOnly([
              "uid",
              "pendingSocietyRequestId",
              "pendingSocietyRequestStatus",
              "updatedAt"
            ])
            && request.resource.data.pendingSocietyRequestId is string
            && request.resource.data.pendingSocietyRequestStatus == "PENDING"
          )
          ||
          // MODE 2: Full pointer create (existing behavior)
          (
            (
              request.auth.uid == uid
              || (
                request.resource.data.societyId is string
                && isAdminOfSociety(request.resource.data.societyId)
              )
              || isGlobalSuperAdmin()
            )
            && request.resource.data.systemRole in ["admin", "guard", "resident"]
            && request.resource.data.societyId is string
            && (request.resource.data.active == true || request.resource.data.active == false)
          )
        );

      // ✅ Update allowed:
      // Self can ONLY update those pointer fields (not role/society/active)
      // Admin/global super admin can update non-identity fields only
      allow update: if signedIn()
        && (
          (
            request.auth.uid == uid
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.diff(resource.data).changedKeys().hasOnly([
              "pendingSocietyRequestId",
              "pendingSocietyRequestStatus",
              "updatedAt"
            ])
            // Freeze sensitive fields if present
            && (!("societyId" in resource.data) || request.resource.data.societyId == resource.data.societyId)
            && (!("systemRole" in resource.data) || request.resource.data.systemRole == resource.data.systemRole)
            && (!("active" in resource.data) || request.resource.data.active == resource.data.active)
          )
          || (
            isGlobalSuperAdmin()
            && request.resource.data.uid == resource.data.uid
            && (!("societyId" in resource.data) || request.resource.data.societyId == resource.data.societyId)
            && (!("systemRole" in resource.data) || request.resource.data.systemRole == resource.data.systemRole)
          )
          || (
            request.resource.data.societyId is string
            && isAdminOfSociety(request.resource.data.societyId)
            && request.resource.data.uid == resource.data.uid
            && (!("societyId" in resource.data) || request.resource.data.societyId == resource.data.societyId)
            && (
              !("systemRole" in resource.data)
              || request.resource.data.systemRole == resource.data.systemRole
            )
            && request.resource.data.systemRole in ["admin", "guard", "resident"]
          )
        );

      allow delete: if false;
    }



    // Helpers for society membership under societies/{societyId}/members/{uid}
    function memberPath(societyId) {
      return /databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid);
    }

    function isMember(societyId) {
      return signedIn() && exists(memberPath(societyId));
    }

    function member(societyId) {
      return get(memberPath(societyId));
    }

    function activeMember(societyId) {
      return isMember(societyId) && member(societyId).data.active == true;
    }

    function isAdmin(societyId) {
      return activeMember(societyId)
        && (member(societyId).data.systemRole == "admin"
            || member(societyId).data.systemRole == "super_admin");
    }

    function isSuperAdmin(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "super_admin";
    }

    function isGuard(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "guard";
    }

    function isResident(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "resident";
    }

    function canReadMemberDoc(societyId, uid) {
      return signedIn()
        && (
          (request.auth.uid == uid
            && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(uid)))
          || isAdmin(societyId)
        );
    }

    // ✅ Allow society creator to re-run creation until membership exists
    function isCreatorBootstrappingSociety(societyId) {
      return signedIn()
        && resource.data.createdByUid == request.auth.uid
        && !exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && request.resource.data.createdByUid == resource.data.createdByUid;
    }

    // ------------------------
    // Societies
    // ------------------------
    match /societies/{societyId} {

      allow create: if false;

      allow read: if activeMember(societyId);

      allow update: if isAdmin(societyId) || isCreatorBootstrappingSociety(societyId);

      allow delete: if isAdmin(societyId);

      match /members/{uid} {

        allow create: if signedIn()
          && request.resource.data.uid == uid
          && request.resource.data.societyId == societyId
          && (request.resource.data.active == true || request.resource.data.active == false)
          && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"]
          && (uid == request.auth.uid || isAdmin(societyId));

        allow read: if signedIn()
          && (
            uid == request.auth.uid
            || isAdmin(societyId)
            || (activeMember(societyId) && member(societyId).data.systemRole == "guard")
          );

        allow update: if signedIn() && (
          (
            uid == request.auth.uid
            && member(societyId).data.systemRole == "guard"
          )
          || (
            uid == request.auth.uid
            && resource.data.active == true
            && request.resource.data.active == false
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
          )
          || (
            uid == request.auth.uid
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
            && request.resource.data.active == resource.data.active
          )
          || isAdmin(societyId)
        );

        allow delete: if isAdmin(societyId);
      }

      match /invites/{inviteKey} {
        allow get: if isAdmin(societyId)
          || (signedIn()
              && request.auth.token.email != null
              && resource.data.email is string
              && resource.data.email.lower() == myEmail());

        allow list: if signedIn()
          && request.auth.token.email != null
          && resource.data.email is string
          && resource.data.email.lower() == myEmail();

        allow create: if isAdmin(societyId)
          && request.resource.data.status == "pending"
          && request.resource.data.active == true
          && request.resource.data.email is string
          && request.resource.data.systemRole in ["guard", "resident", "admin", "super_admin"];

        allow update: if signedIn()
          && request.auth.token.email != null
          && resource.data.status == "pending"
          && resource.data.active == true
          && resource.data.email is string
          && resource.data.email.lower() == myEmail()
          && request.resource.data.status == "claimed"
          && request.resource.data.claimedByUid == request.auth.uid;

        allow delete: if isAdmin(societyId);
      }

      match /notices/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      match /complaints/{id} {
        allow read: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || member(societyId).data.systemRole == "guard"
            || (!("visibility" in resource.data) || resource.data.visibility != "personal")
            || resource.data.residentUid == request.auth.uid
          );
        allow create: if activeMember(societyId)
          && (!("visibility" in request.resource.data) || request.resource.data.visibility in ["general", "personal"]);
        allow update, delete: if isAdmin(societyId);
      }

      match /sos_requests/{id} {
        allow create: if activeMember(societyId);

        allow read: if activeMember(societyId)
          && (
            member(societyId).data.systemRole in ["admin", "super_admin", "guard"]
            || resource.data.residentId == request.auth.uid
          );

        allow update: if activeMember(societyId)
          && member(societyId).data.systemRole in ["admin", "super_admin", "guard"];
        allow delete: if false;
      }

      match /violations/{id} {
        allow create: if isGuard(societyId)
          && request.resource.data.guardUid == request.auth.uid
          && request.resource.data.keys().hasAll(["guardUid", "flatNo", "violationType", "createdAt", "updatedAt"])
          && request.resource.data.violationType in ["PARKING", "FIRE_LANE", "OTHER"];
        allow read: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || (isGuard(societyId) && resource.data.guardUid == request.auth.uid)
            || (isResident(societyId) && resource.data.flatNo != null && member(societyId).data.flatNo != null && resource.data.flatNo.upper() == member(societyId).data.flatNo.upper())
          );
        allow update, delete: if isAdmin(societyId);
      }

      match /visitors/{id} {
        allow read: if activeMember(societyId);
        allow create: if activeMember(societyId)
          && member(societyId).data.systemRole == "guard"
          && request.resource.data.guard_uid == request.auth.uid
          && (
            request.resource.data.status == "PENDING"
            || (
              request.resource.data.status == "APPROVED"
              && request.resource.data.approved_by in ["AUTO_FAVOURITE", "AUTO_PREAPPROVAL"]
            )
          );
        allow update: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || (
              member(societyId).data.systemRole == "resident"
              && resource.data.flat_no.upper() == member(societyId).data.flatNo.upper()
              && request.resource.data.status in ["APPROVED", "REJECTED"]
              && request.resource.data.approved_by == request.auth.uid
            )
          );
        allow delete: if isAdmin(societyId);
      }

      match /residentSignups/{id} {
        allow create: if request.resource.data.status == "PENDING"
          && request.resource.data.society_id == societyId
          && request.resource.data.keys().hasAll(["name", "email", "phone", "flat_no", "password", "signup_id", "society_id"]);

        allow read: if isAdmin(societyId);

        allow update: if isAdmin(societyId)
          && (
            request.resource.data.status in ["APPROVED", "REJECTED"]
            && (request.resource.data.keys().hasAny(["approved_by", "rejected_by"]))
          );

        allow delete: if false;
      }

      match /flats/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // Favorite visitors by unit/flat:
      // societies/{societyId}/units/{unitId}/favorite_visitors/{visitorKey}
      // Guards can read, but cannot write.
      match /units/{unitId} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);

        // Unit-level quick-entry setting
        // societies/{societyId}/units/{unitId}/settings/visitor_access
        match /settings/{settingsId} {
          allow get, list: if activeMember(societyId);
          allow create: if (isAdmin(societyId) || isResident(societyId))
            && request.resource.data.keys().hasOnly([
              "autoApproveFavouritesEnabled",
              "updatedAt",
              "updatedByUid"
            ]);
          allow update: if (isAdmin(societyId) || isResident(societyId))
            && request.resource.data.diff(resource.data).changedKeys().hasOnly([
              "autoApproveFavouritesEnabled",
              "updatedAt",
              "updatedByUid"
            ]);
          allow delete: if isAdmin(societyId);
        }

        match /favorite_visitors/{visitorKey} {
          allow get, list: if activeMember(societyId);
          allow create, update, delete: if isAdmin(societyId) || isResident(societyId);
        }

        // Optional v1 scheduled pre-approvals
        // societies/{societyId}/units/{unitId}/preapprovals/{id}
        match /preapprovals/{preapprovalId} {
          allow get, list: if activeMember(societyId);
          allow create, update, delete: if isAdmin(societyId) || isResident(societyId);
        }
      }

      match /{col}/{doc} {
        allow read, write: if false;
      }
    }

    // ------------------------
    // PUBLIC SOCIETY DIRECTORY (root collection: public_societies)
    // - Readable by signed-in users (active only)
    // - Writable ONLY by Global SUPER_ADMIN (as requested)
    // ------------------------
    match /public_societies/{pubSocietyId} {

      allow read: if signedIn() && resource.data.active == true;

      // ✅ SuperAdmin-only create/update/delete
      allow create, update, delete: if isGlobalSuperAdmin();

      match /units/{unitId} {
        allow read: if signedIn() && resource.data.active == true;
        allow write: if false;
      }

      match /join_requests/{uid} {
        function isSelf() {
          return signedIn() && request.auth.uid == uid;
        }
        function isSocietyAdmin() {
          return isAdmin(pubSocietyId);
        }

        allow create: if isSelf()
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.status == "PENDING";

        allow get: if isSelf() || isSocietyAdmin();
        allow list: if isSocietyAdmin();

        allow update: if (
            isSelf()
            && resource.data.status == "PENDING"
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(
              ["name", "unitLabel", "residencyType"]
            )
          )
          || isSocietyAdmin();

        allow delete: if isSocietyAdmin();
      }
    }

    // Society creation requests (moderated):
    // Normal users can submit; only global super admins can review/approve/reject.
    match /society_creation_requests/{requestId} {
      allow create: if signedIn()
        && request.resource.data.requestedByUid == request.auth.uid
        && request.resource.data.status == "PENDING"
        && request.resource.data.proposedCode is string
        && request.resource.data.proposedName is string
        && request.resource.data.proposedSocietyId is string;

      allow get: if signedIn()
        && (
          resource.data.requestedByUid == request.auth.uid
          || isGlobalSuperAdmin()
        );

      allow list: if isGlobalSuperAdmin();

      // Requester may only edit proposal fields while still pending.
      allow update: if (
          signedIn()
          && resource.data.requestedByUid == request.auth.uid
          && resource.data.status == "PENDING"
          && request.resource.data.status == "PENDING"
          && request.resource.data.diff(resource.data).changedKeys().hasOnly([
            "proposedName",
            "proposedCode",
            "city",
            "state",
            "updatedAt"
          ])
        )
        || isGlobalSuperAdmin();

      allow delete: if false;
    }

    // society code mapping for "join by code"
    match /societyCodes/{code} {
      allow read: if true;

      allow create: if false;

      allow update, delete: if false;
    }

    // unique_phones/{phoneHash}
    match /unique_phones/{phoneHash} {
      allow read: if signedIn();
      allow create: if signedIn()
        && (
          request.resource.data.uid == request.auth.uid
          || (
            request.resource.data.uid is string
            && request.resource.data.societyId is string
            && isAdminOfSociety(request.resource.data.societyId)
          )
          || isGlobalSuperAdmin()
        );
      allow update: if signedIn()
        && (
          (
            resource.data.uid == request.auth.uid
            && request.resource.data.uid == request.auth.uid
          )
          || (
            request.resource.data.uid is string
            && request.resource.data.societyId is string
            && isAdminOfSociety(request.resource.data.societyId)
          )
          || (
            resource.data.societyId is string
            && isAdminOfSociety(resource.data.societyId)
          )
          || isGlobalSuperAdmin()
        );
      allow delete: if false;
    }

    // Guard join codes
    match /guard_join_codes/{code} {
      allow read: if true;
      allow create: if signedIn() && isAdmin(request.resource.data.societyId);
      allow update, delete: if signedIn() && isAdmin(resource.data.societyId);
    }

    // PHONE INDEX
    match /phone_index/{phone} {
      allow read: if signedIn();

      allow create, update: if signedIn()
        && request.auth.token.phone_number != null
        && phone == request.auth.token.phone_number
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.societyId is string
        && request.resource.data.systemRole is string
        && (request.resource.data.active == true || request.resource.data.active == false);

      allow delete: if false;
    }

    match /join_request_index/{uid} {
      // Resident/Admin/Guard can read their own pointer doc
      allow get: if request.auth != null && request.auth.uid == uid;

      // Allow the user to create/update their own pointer at request time
      allow create, update: if request.auth != null && request.auth.uid == uid;

      // Never allow listing all users' pointer docs
      allow list: if false;
    }

    // Platform-level super admins (global, not society-scoped).
    // Clients can only read their own profile for routing; never write.
    match /platform_admins/{uid} {
      allow get: if signedIn() && request.auth.uid == uid;
      allow list: if false;
      allow create, update, delete: if false;
    }

    match /states/{stateId} {
      allow read: if true;
      allow write: if false;

      match /cities/{cityId} {
        allow read: if true;
        allow write: if false;
      }
    }


    // Default deny everything else (KEEP THIS LAST)
    match /{document=**} {
      allow read, write: if false;
    }
  }

    



}
