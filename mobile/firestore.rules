rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    // Helper: auth email lowercased (for invite matching)
    function myEmail() {
      return request.auth.token.email != null
        ? request.auth.token.email.lower()
        : "";
    }

    // =========================
    // ROOT POINTER: members/{uid}
    // Used to resolve societyId WITHOUT collectionGroup queries
    // =========================
    match /members/{uid} {
    // user can read their own pointer; any signed-in user can read (needed for phone-availability check during admin approve)
    allow read: if signedIn();

    // user can create their own pointer
    allow create: if signedIn()
      && request.auth.uid == uid
      && request.resource.data.uid == uid
      && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"]
      && (request.resource.data.active == true || request.resource.data.active == false);

    // ✅ allow:
    // - user updating their own pointer (including deactivation)
    // - OR admin/super_admin updating pointer of someone in the same society (for approval)
    allow update: if signedIn() && (
      // Self update (including deactivation: active true->false)
      request.auth.uid == uid
      || (
        request.resource.data.societyId is string
        && (
          isSuperAdminOfSociety(request.resource.data.societyId)
          || isAdminOfSociety(request.resource.data.societyId)
        )
      )
    );

    allow delete: if false;
  }



    // Helpers for society membership under societies/{societyId}/members/{uid}
    function memberPath(societyId) {
      return /databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid);
    }

    function isMember(societyId) {
      return signedIn() && exists(memberPath(societyId));
    }

    function member(societyId) {
      return get(memberPath(societyId));
    }

    function activeMember(societyId) {
      return isMember(societyId) && member(societyId).data.active == true;
    }

    // ✅ treat super_admin as admin-equivalent
    function isAdmin(societyId) {
      return activeMember(societyId)
        && (member(societyId).data.systemRole == "admin"
            || member(societyId).data.systemRole == "super_admin");
    }

    // ✅ Check if user is super admin
    function isSuperAdmin(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "super_admin";
    }

    // ✅ Check if user is guard (for violations: own reports only)
    function isGuard(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "guard";
    }

    // ✅ Check if user is resident (for violations: own flat only)
    function isResident(societyId) {
      return activeMember(societyId)
        && member(societyId).data.systemRole == "resident";
    }

    // ✅ STEP B: ADD THIS HELPER HERE
    function canReadMemberDoc(societyId, uid) {
      return signedIn()
        && (
          // user can read own member doc even if inactive
          (request.auth.uid == uid
            && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(uid)))
          // admin can read all
          || isAdmin(societyId)
        );
    }

    // ------------------------
    // Societies (multi-tenant root)
    // ------------------------
    match /societies/{societyId} {

      // BOOTSTRAP: allow first-time society creation by the signed-in creator
      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      // After creation, only active members can read the society doc
      allow read: if activeMember(societyId);

      // Only admin can update/delete society doc
      allow update, delete: if isAdmin(societyId);

      // ------------------------
      // Members under society
      // Invite → Self Signup → Claim Invite model
      // ------------------------
      match /members/{uid} {

        // ✅ Self-create: allow active=true (bootstrap) OR active=false (pending signup)
        allow create: if signedIn()
          && uid == request.auth.uid
          && request.resource.data.uid == request.auth.uid
          && (request.resource.data.active == true || request.resource.data.active == false)
          && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"];

        // Read: member can read self (even if inactive); admin can read all; guard can read all (for Residents Directory)
        allow read: if signedIn()
          && (
            uid == request.auth.uid
            || isAdmin(societyId)
            || (activeMember(societyId) && member(societyId).data.systemRole == "guard")
          );

        // Update:
        // - Self can update own member doc even if inactive (profile-only)
        // - Self can deactivate (set active=false)
        // - Admin can update any member (approval, role, etc.)
        allow update: if signedIn() && (
          // Guards: allow self-profile updates (phone/email/photo/shift) without strict role checks
          (
            uid == request.auth.uid
            && member(societyId).data.systemRole == "guard"
          )
          // Self deactivation: allow setting active from true to false
          || (
            uid == request.auth.uid
            && resource.data.active == true
            && request.resource.data.active == false
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
          )
          // Other roles: Self update (even if inactive) — but cannot change role or active
          || (
            uid == request.auth.uid
            && request.resource.data.uid == resource.data.uid
            && request.resource.data.societyId == resource.data.societyId
            && request.resource.data.systemRole == resource.data.systemRole
            && request.resource.data.active == resource.data.active
          )
          // Admin / Super Admin update
          || isAdmin(societyId)
        );


        // Delete: admin/super_admin can delete members (for rejection)
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Invites (email-based onboarding)
      // societies/{societyId}/invites/{inviteKey}
      // ------------------------
      match /invites/{inviteKey} {
        // ✅ Allow reads:
        // - Direct access (get): Admin of this society OR email match
        // - CollectionGroup queries (list): Email match only (societyId not available in collectionGroup context)
        allow get: if isAdmin(societyId)
          || (signedIn()
              && request.auth.token.email != null
              && resource.data.email is string
              && resource.data.email.lower() == myEmail());
        
        // ✅ CollectionGroup queries: Only email-based access (no societyId context)
        // Firestore evaluates this for each document - email must match user's email
        // Query filters handle active/status, rule only needs to check email match
        allow list: if signedIn()
          && request.auth.token.email != null
          && resource.data.email is string
          && resource.data.email.lower() == myEmail();

        // Admin creates invites ONLY
        allow create: if isAdmin(societyId)
          && request.resource.data.status == "pending"
          && request.resource.data.active == true
          && request.resource.data.email is string
          && request.resource.data.systemRole in ["guard", "resident", "admin", "super_admin"];

        // ✅ Claim invite: ONLY invited user can mark pending -> claimed
        allow update: if signedIn()
          && request.auth.token.email != null
          && resource.data.status == "pending"
          && resource.data.active == true
          && resource.data.email is string
          && resource.data.email.lower() == myEmail()
          && request.resource.data.status == "claimed"
          && request.resource.data.claimedByUid == request.auth.uid;

        // Optional: admin cleanup
        allow delete: if isAdmin(societyId);
      }


      // ------------------------
      // Notices (admin writes, members read)
      // ------------------------
      match /notices/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Complaints (members create/read, admin updates)
      // visibility: 'general' = visible to everyone; 'personal' = visible to admins & guards only
      // ------------------------
      match /complaints/{id} {
        allow read: if activeMember(societyId)
          && (
            // Admins and guards can read all complaints
            isAdmin(societyId)
            || member(societyId).data.systemRole == "guard"
            // Residents: general (or missing/legacy) or their own complaint
            || (!("visibility" in resource.data) || resource.data.visibility != "personal")
            || resource.data.residentUid == request.auth.uid
          );
        allow create: if activeMember(societyId)
          && (!("visibility" in request.resource.data) || request.resource.data.visibility in ["general", "personal"]);
        allow update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // SOS Requests
      // Residents can create SOS alerts; admins/guards can read.
      // ------------------------
      match /sos_requests/{id} {
        // Any active member (resident, guard, admin) can create an SOS
        allow create: if activeMember(societyId);

        // Allow reads to staff and the resident who created it
        allow read: if activeMember(societyId)
          && (
            // Admin / super_admin / guard can read all SOS for this society
            member(societyId).data.systemRole in ["admin", "super_admin", "guard"]
            // Or the resident who created the SOS (by residentId field)
            || resource.data.residentId == request.auth.uid
          );

        // Admins/guards can update/close SOS (future: add stricter field checks)
        allow update: if activeMember(societyId)
          && member(societyId).data.systemRole in ["admin", "super_admin", "guard"];
        allow delete: if false;
      }

      // ------------------------
      // Violations (parking / fire-lane - private, no names)
      // Guard: own reports | Admin: full | Resident: only self (by flat)
      // ------------------------
      match /violations/{id} {
        allow create: if isGuard(societyId)
          && request.resource.data.guardUid == request.auth.uid
          && request.resource.data.keys().hasAll(["guardUid", "flatNo", "violationType", "createdAt", "updatedAt"])
          && request.resource.data.violationType in ["PARKING", "FIRE_LANE", "OTHER"];
        allow read: if activeMember(societyId)
          && (
            isAdmin(societyId)
            || (isGuard(societyId) && resource.data.guardUid == request.auth.uid)
            || (isResident(societyId) && resource.data.flatNo != null && member(societyId).data.flatNo != null && resource.data.flatNo.upper() == member(societyId).data.flatNo.upper())
          );
        allow update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Visitors
      // Guards can create visitors, all members can read
      // Residents can update status (approve/reject) for their flat's visitors
      // ------------------------
      match /visitors/{id} {
        allow read: if activeMember(societyId);
        // Guards can create visitors
        allow create: if activeMember(societyId)
          && member(societyId).data.systemRole == "guard"
          && request.resource.data.guard_uid == request.auth.uid
          && request.resource.data.status == "PENDING";
        // Residents can update visitor status (approve/reject) for visitors to their flat
        allow update: if activeMember(societyId)
          && (
            // Admin can update any visitor
            isAdmin(societyId)
            // OR resident can update visitors to their flat (case-insensitive comparison)
            || (
              member(societyId).data.systemRole == "resident"
              && resource.data.flat_no.upper() == member(societyId).data.flatNo.upper()
              && request.resource.data.status in ["APPROVED", "REJECTED"]
              && request.resource.data.approved_by == request.auth.uid
            )
          );
        // Only admin can delete visitors
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Resident Signups
      // Anyone can create signup requests (unauthenticated allowed)
      // Admins can read and update (approve/reject) signup requests
      // ------------------------
      match /residentSignups/{id} {
        // Anyone can create a signup request (unauthenticated allowed)
        // Just validate required fields and status
        allow create: if request.resource.data.status == "PENDING"
          && request.resource.data.society_id == societyId
          && request.resource.data.keys().hasAll(["name", "email", "phone", "flat_no", "password", "signup_id", "society_id"]);
        
        // Only admins can read signup requests
        allow read: if isAdmin(societyId);
        
        // Only admins can update signup requests (approve/reject)
        allow update: if isAdmin(societyId)
          && (
            // Can only update status to APPROVED or REJECTED
            request.resource.data.status in ["APPROVED", "REJECTED"]
            // Must have approved_by or rejected_by field
            && (request.resource.data.keys().hasAny(["approved_by", "rejected_by"]))
          );
        
        // No one can delete signup requests (keep for audit trail)
        allow delete: if false;
      }

      // Note: adminSignups collection removed - admins now use member documents with active=false

      // ------------------------
      // Flats (admin writes, members read)  ✅ moved inside society scope
      // ------------------------
      match /flats/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // Default deny for unknown collections under a society
      match /{col}/{doc} {
        allow read, write: if false;
      }
    }

    // ------------------------
    // PUBLIC SOCIETY DIRECTORY (root collection: public_societies)
    // public_societies/{societyId}
    // public_societies/{societyId}/units/{unitId}
    // public_societies/{societyId}/join_requests/{uid}
    // ------------------------
    match /public_societies/{pubSocietyId} {
      // Any signed-in user can read active public society metadata
      allow read: if signedIn()
        && resource.data.active == true;

      // Admins of this society may update nameLower only (for search after name change).
      allow update: if signedIn()
        && isAdmin(pubSocietyId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['nameLower'])
        && request.resource.data.nameLower is string;
      // Create/delete managed by backend / admin tools only
      allow create, delete: if false;

      // Units under a public society
      match /units/{unitId} {
        allow read: if signedIn()
          && resource.data.active == true;
        allow write: if false;
      }

      // Resident join requests under a public society
      match /join_requests/{uid} {
        function isSelf() {
          return signedIn() && request.auth.uid == uid;
        }
        function isSocietyAdmin() {
          return isAdmin(pubSocietyId);
        }
        allow create: if isSelf()
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.status == "PENDING";
        allow get: if isSelf() || isSocietyAdmin();
        allow list: if isSocietyAdmin();
        allow update: if isSelf()
            && resource.data.status == "PENDING"
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(
              ["name", "unitLabel", "residencyType"]
            )
          || isSocietyAdmin();
        allow delete: if isSocietyAdmin();
      }
    }

    // society code mapping for "join by code"
    // This is intentionally public-read so onboarding (before login) can resolve a society from a code.
    match /societyCodes/{code} {
      // Anyone (even unauthenticated) can read societyCodes
      allow read: if true;

      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      // keep locked for now
      allow update, delete: if false;
    }

    function isSuperAdminOfSociety(societyId) {
      return signedIn()
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin";
    }

    function isAdminOfSociety(societyId) {
      return signedIn()
        && exists(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.active == true
        && (
          get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "admin"
          || get(/databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid)).data.systemRole == "super_admin"
        );
    }

    // ------------------------
    // unique_phones/{phoneHash} - one active account per phone. Read/write for phone check and setMemberPhone (approve, profile link).
    // ------------------------
    match /unique_phones/{phoneHash} {
      allow read, write: if signedIn();
    }

    // ------------------------
    // Guard join codes (6-digit, 24h validity). Admin creates; guard reads by code to get societyId.
    // ------------------------
    match /guard_join_codes/{code} {
      allow read: if true;
      allow create: if signedIn() && isAdmin(request.resource.data.societyId);
      allow update, delete: if signedIn() && isAdmin(resource.data.societyId);
    }

    // Default deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
