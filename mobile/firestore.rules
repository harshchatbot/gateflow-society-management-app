rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    // Helper: auth email lowercased (for invite matching)
    function myEmail() {
      return request.auth.token.email != null
        ? request.auth.token.email.lower()
        : "";
    }

    // =========================
    // ROOT POINTER: members/{uid}
    // Used to resolve societyId WITHOUT collectionGroup queries
    // =========================
    match /members/{uid} {
      allow read: if signedIn() && request.auth.uid == uid;

      // user can create their own pointer
      allow create: if signedIn()
        && request.auth.uid == uid
        && request.resource.data.uid == uid
        && request.resource.data.active == true
        // allow any of these because claim writes guard/resident too
        && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"];

      // user can update their own pointer
      allow update: if signedIn() && request.auth.uid == uid;

      allow delete: if false;
    }

    // Helpers for society membership under societies/{societyId}/members/{uid}
    function memberPath(societyId) {
      return /databases/$(database)/documents/societies/$(societyId)/members/$(request.auth.uid);
    }

    function isMember(societyId) {
      return signedIn() && exists(memberPath(societyId));
    }

    function member(societyId) {
      return get(memberPath(societyId));
    }

    function activeMember(societyId) {
      return isMember(societyId) && member(societyId).data.active == true;
    }

    // ✅ treat super_admin as admin-equivalent
    function isAdmin(societyId) {
      return activeMember(societyId)
        && (member(societyId).data.systemRole == "admin"
            || member(societyId).data.systemRole == "super_admin");
    }

    // ------------------------
    // Societies (multi-tenant root)
    // ------------------------
    match /societies/{societyId} {

      // BOOTSTRAP: allow first-time society creation by the signed-in creator
      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      // After creation, only active members can read the society doc
      allow read: if activeMember(societyId);

      // Only admin can update/delete society doc
      allow update, delete: if isAdmin(societyId);

      // ------------------------
      // Members under society
      // Invite → Self Signup → Claim Invite model
      // ------------------------
      match /members/{uid} {

        // ✅ ONLY self-create (bootstrap admin OR claimed invite user)
        allow create: if signedIn()
          && uid == request.auth.uid
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.active == true
          && request.resource.data.systemRole in ["admin", "super_admin", "guard", "resident"];

        // Read: member can read self; admin can read all
        allow read: if activeMember(societyId)
          && (uid == request.auth.uid || isAdmin(societyId));

        // Update: member can update self; admin can update all
        allow update: if activeMember(societyId)
          && (uid == request.auth.uid || isAdmin(societyId));

        // Delete: admin only
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Invites (email-based onboarding)
      // societies/{societyId}/invites/{inviteKey}
      // ------------------------
      match /invites/{inviteKey} {
        // ✅ Allow reads:
        // - Direct access (get): Admin of this society OR email match
        // - CollectionGroup queries (list): Email match only (societyId not available in collectionGroup context)
        allow get: if isAdmin(societyId)
          || (signedIn()
              && request.auth.token.email != null
              && resource.data.email is string
              && resource.data.email.lower() == myEmail());
        
        // ✅ CollectionGroup queries: Only email-based access (no societyId context)
        // Firestore evaluates this for each document - email must match user's email
        // Query filters handle active/status, rule only needs to check email match
        allow list: if signedIn()
          && request.auth.token.email != null
          && resource.data.email is string
          && resource.data.email.lower() == myEmail();

        // Admin creates invites ONLY
        allow create: if isAdmin(societyId)
          && request.resource.data.status == "pending"
          && request.resource.data.active == true
          && request.resource.data.email is string
          && request.resource.data.systemRole in ["guard", "resident", "admin", "super_admin"];

        // ✅ Claim invite: ONLY invited user can mark pending -> claimed
        allow update: if signedIn()
          && request.auth.token.email != null
          && resource.data.status == "pending"
          && resource.data.active == true
          && resource.data.email is string
          && resource.data.email.lower() == myEmail()
          && request.resource.data.status == "claimed"
          && request.resource.data.claimedByUid == request.auth.uid;

        // Optional: admin cleanup
        allow delete: if isAdmin(societyId);
      }


      // ------------------------
      // Notices (admin writes, members read)
      // ------------------------
      match /notices/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Complaints (members create/read, admin updates)
      // ------------------------
      match /complaints/{id} {
        allow read: if activeMember(societyId);
        allow create: if activeMember(societyId);
        allow update, delete: if isAdmin(societyId);
      }

      // ------------------------
      // Visitors
      // Guards can create visitors, all members can read
      // Residents can update status (approve/reject) for their flat's visitors
      // ------------------------
      match /visitors/{id} {
        allow read: if activeMember(societyId);
        // Guards can create visitors
        allow create: if activeMember(societyId)
          && member(societyId).data.systemRole == "guard"
          && request.resource.data.guard_uid == request.auth.uid
          && request.resource.data.status == "PENDING";
        // Residents can update visitor status (approve/reject) for visitors to their flat
        allow update: if activeMember(societyId)
          && (
            // Admin can update any visitor
            isAdmin(societyId)
            // OR resident can update visitors to their flat (case-insensitive comparison)
            || (
              member(societyId).data.systemRole == "resident"
              && resource.data.flat_no.upper() == member(societyId).data.flatNo.upper()
              && request.resource.data.status in ["APPROVED", "REJECTED"]
              && request.resource.data.approved_by == request.auth.uid
            )
          );
        // Only admin can delete visitors
        allow delete: if isAdmin(societyId);
      }

      // ------------------------
      // Flats (admin writes, members read)  ✅ moved inside society scope
      // ------------------------
      match /flats/{id} {
        allow read: if activeMember(societyId);
        allow create, update, delete: if isAdmin(societyId);
      }

      // Default deny for unknown collections under a society
      match /{col}/{doc} {
        allow read, write: if false;
      }
    }

    // society code mapping for "join by code"
    match /societyCodes/{code} {
      allow read: if signedIn();

      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.active == true;

      // keep locked for now
      allow update, delete: if false;
    }

    // Default deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
